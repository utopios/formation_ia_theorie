<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation R√©seau Bay√©sien</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #8E24AA 0%, #3F51B5 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .inference-btn { background: linear-gradient(45deg, #4CAF50, #45a049); }
        .evidence-btn { background: linear-gradient(45deg, #FF9800, #F57C00); }
        .reset-btn { background: linear-gradient(45deg, #E91E63, #C2185B); }
        .learning-btn { background: linear-gradient(45deg, #9C27B0, #7B1FA2); }

        .network-container {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            min-height: 600px;
            position: relative;
        }

        .scenario-info {
            text-align: center;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .scenario-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }

        .network-graph {
            position: relative;
            height: 500px;
            margin: 20px 0;
        }

        .node {
            position: absolute;
            width: 120px;
            height: 80px;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.5s ease;
            border: 3px solid rgba(255, 255, 255, 0.5);
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .node:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(255, 255, 255, 0.3);
        }

        .weather-node { background: linear-gradient(135deg, #87CEEB, #4682B4); top: 50px; left: 50%; transform: translateX(-50%); }
        .sprinkler-node { background: linear-gradient(135deg, #98FB98, #228B22); top: 180px; left: 20%; }
        .rain-node { background: linear-gradient(135deg, #4169E1, #191970); top: 180px; right: 20%; }
        .wet-grass-node { background: linear-gradient(135deg, #32CD32, #006400); top: 320px; left: 50%; transform: translateX(-50%); }

        .node.observed {
            border-color: #FFD700;
            border-width: 4px;
            animation: pulse 2s infinite;
        }

        .node.queried {
            border-color: #FF5722;
            border-width: 4px;
            animation: glow 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 1); }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 87, 34, 0.7); }
            50% { box-shadow: 0 0 25px rgba(255, 87, 34, 1); }
        }

        .edge {
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            transform-origin: left center;
            transition: all 0.5s ease;
        }

        .edge.active {
            background: #FFD700;
            height: 4px !important;
            box-shadow: 0 0 10px #FFD700;
        }

        .arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            transition: all 0.5s ease;
        }

        .arrow.active {
            border-left-color: #FFD700 !important;
            filter: drop-shadow(0 0 5px #FFD700);
        }

        .probability-table {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .table-title {
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #FFD700;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        th {
            background: rgba(255, 255, 255, 0.2);
            font-weight: bold;
        }

        .probability-highlight {
            background: rgba(255, 215, 0, 0.3) !important;
            border: 2px solid #FFD700 !important;
            font-weight: bold;
        }

        .inference-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 30px;
        }

        .evidence-panel, .query-panel {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #FFD700;
        }

        .evidence-item, .query-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .evidence-item.active {
            background: rgba(255, 152, 0, 0.3);
            border: 2px solid #FF9800;
        }

        select, input {
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }

        .result-display {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .result-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #4CAF50;
            margin: 15px 0;
        }

        .calculation-steps {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 0.9em;
        }

        .step {
            margin: 8px 0;
            padding: 5px;
            transition: all 0.3s ease;
        }

        .step.active {
            background: rgba(255, 215, 0, 0.3);
            border-left: 4px solid #FFD700;
            padding-left: 15px;
        }

        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .inference-panel {
                grid-template-columns: 1fr;
            }
            
            .node {
                width: 100px;
                height: 70px;
                font-size: 12px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Animation R√©seau Bay√©sien</h1>
        
        <div class="controls">
            <button class="inference-btn" onclick="runInference()">üîç Inf√©rence Bay√©sienne</button>
            <button class="evidence-btn" onclick="addEvidence()">üìù Ajouter Evidence</button>
            <button class="learning-btn" onclick="learnStructure()">üß† Apprentissage</button>
            <button class="reset-btn" onclick="resetNetwork()">üîÑ Reset</button>
        </div>

        <!-- Sc√©nario -->
        <div class="scenario-info">
            <div class="scenario-title">üåßÔ∏è Sc√©nario : Pr√©diction de l'herbe mouill√©e</div>
            <p>Un r√©seau bay√©sien pour d√©terminer si l'herbe sera mouill√©e en fonction de la m√©t√©o, de l'arrosoir et de la pluie.</p>
        </div>

        <div class="network-container">
            <!-- Graphe du r√©seau -->
            <div class="network-graph" id="network-graph">
                <!-- N≈ìuds -->
                <div class="node weather-node" id="weather" onclick="selectNode('weather')">
                    <div>üå§Ô∏è M√©t√©o</div>
                    <div id="weather-prob">P = ?</div>
                </div>
                
                <div class="node sprinkler-node" id="sprinkler" onclick="selectNode('sprinkler')">
                    <div>üöø Arrosoir</div>
                    <div id="sprinkler-prob">P = ?</div>
                </div>
                
                <div class="node rain-node" id="rain" onclick="selectNode('rain')">
                    <div>üåßÔ∏è Pluie</div>
                    <div id="rain-prob">P = ?</div>
                </div>
                
                <div class="node wet-grass-node" id="wet-grass" onclick="selectNode('wet-grass')">
                    <div>üå± Herbe Mouill√©e</div>
                    <div id="wet-grass-prob">P = ?</div>
                </div>

                <!-- Ar√™tes (seront cr√©√©es dynamiquement) -->
            </div>

            <!-- L√©gende -->
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700; border: 2px solid #FFD700;"></div>
                    <span>N≈ìud avec Evidence</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF5722; border: 2px solid #FF5722;"></div>
                    <span>N≈ìud Requ√™te</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Flux d'Information Actif</span>
                </div>
            </div>
        </div>

        <!-- Panneau d'inf√©rence -->
        <div class="inference-panel">
            <div class="evidence-panel">
                <div class="panel-title">üìù Evidence Observ√©e</div>
                <div class="evidence-item">
                    <span>M√©t√©o:</span>
                    <select id="weather-evidence">
                        <option value="">Non observ√©</option>
                        <option value="sunny">Ensoleill√©</option>
                        <option value="cloudy">Nuageux</option>
                    </select>
                </div>
                <div class="evidence-item">
                    <span>Arrosoir:</span>
                    <select id="sprinkler-evidence">
                        <option value="">Non observ√©</option>
                        <option value="on">Activ√©</option>
                        <option value="off">D√©sactiv√©</option>
                    </select>
                </div>
                <div class="evidence-item">
                    <span>Pluie:</span>
                    <select id="rain-evidence">
                        <option value="">Non observ√©</option>
                        <option value="yes">Oui</option>
                        <option value="no">Non</option>
                    </select>
                </div>
            </div>

            <div class="query-panel">
                <div class="panel-title">‚ùì Requ√™te</div>
                <div class="query-item">
                    <span>Calculer P(Herbe Mouill√©e | Evidence):</span>
                    <select id="wet-grass-query">
                        <option value="yes">Oui</option>
                        <option value="no">Non</option>
                    </select>
                </div>
                <div class="result-display" id="result-display" style="display: none;">
                    <div>Probabilit√© Calcul√©e:</div>
                    <div class="result-value" id="result-value">0.00</div>
                    <div id="result-explanation"></div>
                </div>
            </div>
        </div>

        <!-- Tables de probabilit√©s conditionnelles -->
        <div class="probability-table" id="cpt-container">
            <div class="table-title">üìä Tables de Probabilit√©s Conditionnelles (CPT)</div>
            <div id="tables-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;"></div>
        </div>

        <!-- √âtapes de calcul -->
        <div class="calculation-steps" id="calculation-steps" style="display: none;">
            <h4>üßÆ √âtapes de Calcul de l'Inf√©rence</h4>
            <div id="steps-container"></div>
        </div>

        <!-- Explication -->
        <div class="probability-table">
            <div class="table-title">üéØ Comment fonctionne un R√©seau Bay√©sien</div>
            <p><strong>1. Structure :</strong> Un graphe acyclique dirig√© o√π chaque n≈ìud repr√©sente une variable al√©atoire.</p>
            <p><strong>2. Probabilit√©s :</strong> Chaque n≈ìud a une table de probabilit√©s conditionnelles (CPT) qui d√©pend de ses parents.</p>
            <p><strong>3. Ind√©pendance :</strong> Les variables sont conditionnellement ind√©pendantes de leurs non-descendants √©tant donn√©s leurs parents.</p>
            <p><strong>4. Inf√©rence :</strong> Utilise le th√©or√®me de Bayes pour calculer P(Requ√™te | Evidence) en propageant les probabilit√©s.</p>
            <p><strong>5. Applications :</strong> Diagnostic m√©dical, pr√©diction m√©t√©o, reconnaissance de formes, syst√®mes experts.</p>
        </div>
    </div>

    <script>
        // Structure du r√©seau bay√©sien
        const network = {
            nodes: ['weather', 'sprinkler', 'rain', 'wet-grass'],
            edges: [
                { from: 'weather', to: 'sprinkler' },
                { from: 'weather', to: 'rain' },
                { from: 'sprinkler', to: 'wet-grass' },
                { from: 'rain', to: 'wet-grass' }
            ],
            evidence: {},
            query: null
        };

        // Tables de probabilit√©s conditionnelles
        const cpts = {
            weather: {
                // P(Weather)
                sunny: 0.7,
                cloudy: 0.3
            },
            sprinkler: {
                // P(Sprinkler | Weather)
                sunny: { on: 0.8, off: 0.2 },
                cloudy: { on: 0.2, off: 0.8 }
            },
            rain: {
                // P(Rain | Weather)
                sunny: { yes: 0.1, no: 0.9 },
                cloudy: { yes: 0.8, no: 0.2 }
            },
            'wet-grass': {
                // P(Wet Grass | Sprinkler, Rain)
                on: {
                    yes: { yes: 0.99, no: 0.01 },
                    no: { yes: 0.9, no: 0.1 }
                },
                off: {
                    yes: { yes: 0.8, no: 0.2 },
                    no: { yes: 0.05, no: 0.95 }
                }
            }
        };

        let isAnimating = false;

        // Initialisation
        function initializeNetwork() {
            createEdges();
            createCPTTables();
            updateProbabilities();
        }

        function createEdges() {
            const graph = document.getElementById('network-graph');
            
            // Nettoyer les anciennes ar√™tes
            graph.querySelectorAll('.edge, .arrow').forEach(el => el.remove());
            
            // Positions des n≈ìuds
            const positions = {
                weather: { x: 50, y: 90, width: 120 },
                sprinkler: { x: 20, y: 220, width: 120 },
                rain: { x: 80, y: 220, width: 120 },
                'wet-grass': { x: 50, y: 360, width: 120 }
            };

            network.edges.forEach(edge => {
                const fromPos = positions[edge.from];
                const toPos = positions[edge.to];
                
                if (!fromPos || !toPos) return;
                
                // Calculer la position et l'angle
                const startX = fromPos.x + fromPos.width / 2;
                const startY = fromPos.y + 40; // Milieu vertical du n≈ìud
                const endX = toPos.x + toPos.width / 2;
                const endY = toPos.y;
                
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                
                // Cr√©er la ligne
                const line = document.createElement('div');
                line.className = `edge edge-${edge.from}-${edge.to}`;
                line.style.cssText = `
                    left: ${startX}px;
                    top: ${startY}px;
                    width: ${length}px;
                    height: 2px;
                    transform: rotate(${angle}deg);
                `;
                
                // Cr√©er la fl√®che
                const arrow = document.createElement('div');
                arrow.className = `arrow arrow-${edge.from}-${edge.to}`;
                arrow.style.cssText = `
                    left: ${endX - 5}px;
                    top: ${endY - 5}px;
                    border-left: 10px solid rgba(255, 255, 255, 0.7);
                    border-top: 5px solid transparent;
                    border-bottom: 5px solid transparent;
                `;
                
                graph.appendChild(line);
                graph.appendChild(arrow);
            });
        }

        function createCPTTables() {
            const container = document.getElementById('tables-grid');
            container.innerHTML = '';

            // Table pour Weather (n≈ìud racine)
            const weatherTable = createTable('M√©t√©o', [
                ['√âtat', 'Probabilit√©'],
                ['Ensoleill√©', '0.70'],
                ['Nuageux', '0.30']
            ]);

            // Table pour Sprinkler
            const sprinklerTable = createTable('Arrosoir | M√©t√©o', [
                ['M√©t√©o', 'Arrosoir=On', 'Arrosoir=Off'],
                ['Ensoleill√©', '0.80', '0.20'],
                ['Nuageux', '0.20', '0.80']
            ]);

            // Table pour Rain
            const rainTable = createTable('Pluie | M√©t√©o', [
                ['M√©t√©o', 'Pluie=Oui', 'Pluie=Non'],
                ['Ensoleill√©', '0.10', '0.90'],
                ['Nuageux', '0.80', '0.20']
            ]);

            // Table pour Wet Grass
            const wetGrassTable = createTable('Herbe Mouill√©e | Arrosoir, Pluie', [
                ['Arrosoir', 'Pluie', 'Mouill√©e=Oui', 'Mouill√©e=Non'],
                ['On', 'Oui', '0.99', '0.01'],
                ['On', 'Non', '0.90', '0.10'],
                ['Off', 'Oui', '0.80', '0.20'],
                ['Off', 'Non', '0.05', '0.95']
            ]);

            container.appendChild(weatherTable);
            container.appendChild(sprinklerTable);
            container.appendChild(rainTable);
            container.appendChild(wetGrassTable);
        }

        function createTable(title, data) {
            const div = document.createElement('div');
            div.innerHTML = `
                <h4 style="text-align: center; margin-bottom: 10px; color: #FFD700;">${title}</h4>
                <table>
                    ${data.map((row, i) => `
                        <tr>
                            ${row.map((cell, j) => `
                                <${i === 0 ? 'th' : 'td'}>${cell}</${i === 0 ? 'th' : 'td'}>
                            `).join('')}
                        </tr>
                    `).join('')}
                </table>
            `;
            return div;
        }

        async function runInference() {
            if (isAnimating) return;
            isAnimating = true;

            // Collecter les evidences
            collectEvidence();
            
            if (Object.keys(network.evidence).length === 0) {
                alert('Veuillez d\'abord ajouter au moins une evidence !');
                isAnimating = false;
                return;
            }

            // Animer le flux d'information
            await animateInferenceFlow();
            
            // Calculer la probabilit√©
            const result = calculateInference();
            
            // Afficher le r√©sultat
            displayResult(result);
            
            isAnimating = false;
        }

        function collectEvidence() {
            network.evidence = {};
            
            const weatherEvidence = document.getElementById('weather-evidence').value;
            const sprinklerEvidence = document.getElementById('sprinkler-evidence').value;
            const rainEvidence = document.getElementById('rain-evidence').value;
            
            if (weatherEvidence) network.evidence.weather = weatherEvidence;
            if (sprinklerEvidence) network.evidence.sprinkler = sprinklerEvidence;
            if (rainEvidence) network.evidence.rain = rainEvidence;
            
            // Mettre √† jour l'affichage visuel
            updateEvidenceDisplay();
        }

        function updateEvidenceDisplay() {
            // Reset tous les n≈ìuds
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('observed', 'queried');
            });

            // Marquer les n≈ìuds avec evidence
            Object.keys(network.evidence).forEach(node => {
                document.getElementById(node).classList.add('observed');
            });

            // Marquer le n≈ìud requ√™te
            document.getElementById('wet-grass').classList.add('queried');
        }

        async function animateInferenceFlow() {
            // Activer les ar√™tes dans l'ordre de propagation
            const propagationOrder = [
                'edge-weather-sprinkler',
                'edge-weather-rain',
                'edge-sprinkler-wet-grass',
                'edge-rain-wet-grass'
            ];

            for (const edgeClass of propagationOrder) {
                const edge = document.querySelector(`.${edgeClass}`);
                const arrow = document.querySelector(`.arrow-${edgeClass.split('-').slice(1).join('-')}`);
                
                if (edge && arrow) {
                    edge.classList.add('active');
                    arrow.classList.add('active');
                    await sleep(800);
                }
            }

            await sleep(1000);

            // D√©sactiver les ar√™tes
            document.querySelectorAll('.edge, .arrow').forEach(el => {
                el.classList.remove('active');
            });
        }

        function calculateInference() {
            // Impl√©mentation simplifi√©e du calcul bay√©sien
            const queryValue = document.getElementById('wet-grass-query').value;
            
            let probability = 0;
            let totalProbability = 0;
            const steps = [];

            // √ânum√©rer toutes les configurations possibles
            const weatherStates = network.evidence.weather ? [network.evidence.weather] : ['sunny', 'cloudy'];
            const sprinklerStates = network.evidence.sprinkler ? [network.evidence.sprinkler] : ['on', 'off'];
            const rainStates = network.evidence.rain ? [network.evidence.rain] : ['yes', 'no'];

            weatherStates.forEach(weather => {
                sprinklerStates.forEach(sprinkler => {
                    rainStates.forEach(rain => {
                        // Calculer P(tous les √©tats)
                        let jointProb = cpts.weather[weather];
                        jointProb *= cpts.sprinkler[weather][sprinkler];
                        jointProb *= cpts.rain[weather][rain];
                        jointProb *= cpts['wet-grass'][sprinkler][rain][queryValue];

                        probability += jointProb;

                        // Pour la normalisation
                        const totalJointProb = cpts.weather[weather] * 
                                             cpts.sprinkler[weather][sprinkler] * 
                                             cpts.rain[weather][rain];
                        totalProbability += totalJointProb;

                        steps.push({
                            weather, sprinkler, rain,
                            prob: jointProb,
                            calculation: `P(${weather}, ${sprinkler}, ${rain}, wet=${queryValue}) = ${jointProb.toFixed(4)}`
                        });
                    });
                });
            });

            // Normalisation si n√©cessaire
            if (!network.evidence.weather && !network.evidence.sprinkler && !network.evidence.rain) {
                // Pas d'evidence, juste la probabilit√© marginale
            } else {
                // Avec evidence, normaliser
                probability = probability / totalProbability;
            }

            displayCalculationSteps(steps);
            
            return {
                probability: Math.min(1, Math.max(0, probability)),
                steps: steps
            };
        }

        function displayCalculationSteps(steps) {
            const container = document.getElementById('steps-container');
            const stepsDiv = document.getElementById('calculation-steps');
            
            container.innerHTML = '';
            steps.forEach((step, i) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'step';
                stepDiv.textContent = step.calculation;
                container.appendChild(stepDiv);
            });
            
            stepsDiv.style.display = 'block';
        }

        function displayResult(result) {
            const resultDisplay = document.getElementById('result-display');
            const resultValue = document.getElementById('result-value');
            const resultExplanation = document.getElementById('result-explanation');
            
            resultDisplay.style.display = 'block';
            resultValue.textContent = (result.probability * 100).toFixed(1) + '%';
            
            const queryValue = document.getElementById('wet-grass-query').value;
            const evidenceText = Object.entries(network.evidence)
                .map(([key, value]) => `${key}=${value}`)
                .join(', ');
            
            resultExplanation.innerHTML = `
                P(Herbe Mouill√©e = ${queryValue} | ${evidenceText || 'Aucune evidence'})
                <br><small>Calcul√© par inf√©rence bay√©sienne exacte</small>
            `;

            // Animer le r√©sultat
            resultValue.style.animation = 'none';
            setTimeout(() => {
                resultValue.style.animation = 'pulse 2s infinite';
            }, 100);
        }

        async function addEvidence() {
            if (isAnimating) return;
            isAnimating = true;
            
            // Collecter et valider les evidences
            collectEvidence();
            
            if (Object.keys(network.evidence).length === 0) {
                alert('Veuillez s√©lectionner au moins une evidence dans les menus d√©roulants !');
                isAnimating = false;
                return;
            }
            
            // Animer l'ajout d'evidence
            await animateEvidenceAddition();
            
            // Mettre √† jour les probabilit√©s
            updateProbabilities();
            
            isAnimating = false;
        }

        async function animateEvidenceAddition() {
            // Animer chaque n≈ìud avec evidence
            for (const [node, value] of Object.entries(network.evidence)) {
                const nodeElement = document.getElementById(node);
                const evidenceItem = document.querySelector(`#${node}-evidence`).parentElement;
                
                // Animer le panneau d'evidence
                evidenceItem.classList.add('active');
                
                // Animer le n≈ìud
                nodeElement.classList.add('observed');
                
                // Afficher la valeur d'evidence
                const probElement = document.getElementById(`${node}-prob`);
                probElement.textContent = `E: ${value}`;
                
                await sleep(500);
            }
        }

        function updateProbabilities() {
            // Mettre √† jour l'affichage des probabilit√©s sur les n≈ìuds
            Object.keys(cpts).forEach(node => {
                const probElement = document.getElementById(`${node}-prob`);
                if (network.evidence[node]) {
                    probElement.textContent = `E: ${network.evidence[node]}`;
                } else {
                    // Calculer la probabilit√© marginale
                    const marginal = calculateMarginalProbability(node);
                    probElement.textContent = `P ‚âà ${(marginal * 100).toFixed(0)}%`;
                }
            });
        }

        function calculateMarginalProbability(node) {
            // Calcul simplifi√© de la probabilit√© marginale
            switch(node) {
                case 'weather':
                    return network.evidence.weather ? 1.0 : 0.7; // Prior pour sunny
                case 'sprinkler':
                    return network.evidence.sprinkler ? 1.0 : 0.5; // Moyenne approximative
                case 'rain':
                    return network.evidence.rain ? 1.0 : 0.45; // Moyenne approximative
                case 'wet-grass':
                    return 0.4; // Estimation bas√©e sur la structure
                default:
                    return 0.5;
            }
        }

        async function learnStructure() {
            if (isAnimating) return;
            isAnimating = true;
            
            // Simulation de l'apprentissage de structure
            const steps = [
                'Analyse des donn√©es d\'entra√Ænement...',
                'Calcul des scores de structure...',
                'Test d\'ind√©pendance conditionnelle...',
                'Optimisation de la structure...',
                'Estimation des param√®tres...',
                'Validation crois√©e...'
            ];
            
            for (const [i, step] of steps.entries()) {
                updateLearningProgress(step, (i + 1) / steps.length);
                
                // Animer les ar√™tes pendant l'apprentissage
                if (i >= 2) {
                    const edges = document.querySelectorAll('.edge');
                    edges.forEach(edge => {
                        edge.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
                        edge.style.height = `${2 + Math.random() * 4}px`;
                    });
                }
                
                await sleep(1500);
            }
            
            // Restaurer l'apparence normale
            document.querySelectorAll('.edge').forEach(edge => {
                edge.style.background = 'rgba(255, 255, 255, 0.7)';
                edge.style.height = '2px';
            });
            
            updateLearningProgress('Apprentissage termin√© ! Structure optimis√©e.', 1);
            
            isAnimating = false;
        }

        function updateLearningProgress(message, progress) {
            const container = document.querySelector('.scenario-info');
            container.innerHTML = `
                <div class="scenario-title">üß† Apprentissage de Structure</div>
                <p>${message}</p>
                <div style="background: rgba(255,255,255,0.3); border-radius: 10px; height: 20px; margin: 15px 0; overflow: hidden;">
                    <div style="background: #4CAF50; height: 100%; width: ${progress * 100}%; transition: width 0.5s ease; border-radius: 10px;"></div>
                </div>
                <p>Progression: ${(progress * 100).toFixed(0)}%</p>
            `;
        }

        function resetNetwork() {
            network.evidence = {};
            network.query = null;
            isAnimating = false;
            
            // Reset de l'interface
            document.querySelectorAll('select').forEach(select => select.value = '');
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('observed', 'queried');
            });
            document.querySelectorAll('.evidence-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelectorAll('.edge, .arrow').forEach(el => {
                el.classList.remove('active');
            });
            
            // Reset des affichages
            document.getElementById('result-display').style.display = 'none';
            document.getElementById('calculation-steps').style.display = 'none';
            
            // Restaurer le sc√©nario initial
            document.querySelector('.scenario-info').innerHTML = `
                <div class="scenario-title">üåßÔ∏è Sc√©nario : Pr√©diction de l'herbe mouill√©e</div>
                <p>Un r√©seau bay√©sien pour d√©terminer si l'herbe sera mouill√©e en fonction de la m√©t√©o, de l'arrosoir et de la pluie.</p>
            `;
            
            updateProbabilities();
        }

        function selectNode(nodeId) {
            if (isAnimating) return;
            
            // Afficher les informations du n≈ìud s√©lectionn√©
            showNodeDetails(nodeId);
        }

        function showNodeDetails(nodeId) {
            const details = {
                weather: {
                    name: 'M√©t√©o',
                    type: 'N≈ìud racine (pas de parents)',
                    states: ['Ensoleill√©', 'Nuageux'],
                    description: 'Repr√©sente les conditions m√©t√©orologiques actuelles.'
                },
                sprinkler: {
                    name: 'Arrosoir',
                    type: 'D√©pend de : M√©t√©o',
                    states: ['Activ√©', 'D√©sactiv√©'],
                    description: 'L\'arrosoir est plus souvent utilis√© par temps ensoleill√©.'
                },
                rain: {
                    name: 'Pluie',
                    type: 'D√©pend de : M√©t√©o',
                    states: ['Oui', 'Non'],
                    description: 'La probabilit√© de pluie d√©pend de la m√©t√©o.'
                },
                'wet-grass': {
                    name: 'Herbe Mouill√©e',
                    type: 'D√©pend de : Arrosoir, Pluie',
                    states: ['Oui', 'Non'],
                    description: 'L\'herbe peut √™tre mouill√©e par l\'arrosoir ou la pluie.'
                }
            };
            
            const detail = details[nodeId];
            if (detail) {
                alert(`${detail.name}\n\n${detail.type}\n√âtats possibles: ${detail.states.join(', ')}\n\n${detail.description}`);
            }
        }

        // Fonctions utilitaires
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Fonctionnalit√©s avanc√©es
        async function runSensitivityAnalysis() {
            if (isAnimating) return;
            isAnimating = true;
            
            const results = [];
            const originalEvidence = {...network.evidence};
            
            // Tester diff√©rentes combinaisons d'evidence
            const testCases = [
                { weather: 'sunny' },
                { weather: 'cloudy' },
                { weather: 'sunny', sprinkler: 'on' },
                { weather: 'cloudy', rain: 'yes' },
                { sprinkler: 'on', rain: 'no' }
            ];
            
            for (const testCase of testCases) {
                network.evidence = testCase;
                const result = calculateInference();
                results.push({
                    evidence: testCase,
                    probability: result.probability
                });
                
                // Animation visuelle
                updateEvidenceDisplay();
                await sleep(1000);
            }
            
            // Restaurer l'evidence originale
            network.evidence = originalEvidence;
            updateEvidenceDisplay();
            
            // Afficher les r√©sultats
            showSensitivityResults(results);
            
            isAnimating = false;
        }

        function showSensitivityResults(results) {
            const container = document.querySelector('.scenario-info');
            let html = '<div class="scenario-title">üìä Analyse de Sensibilit√©</div>';
            html += '<table style="width: 100%; margin: 15px 0;"><tr><th>Evidence</th><th>P(Herbe Mouill√©e = Oui)</th></tr>';
            
            results.forEach(result => {
                const evidenceStr = Object.entries(result.evidence)
                    .map(([k, v]) => `${k}=${v}`)
                    .join(', ');
                html += `<tr><td>${evidenceStr}</td><td>${(result.probability * 100).toFixed(1)}%</td></tr>`;
            });
            
            html += '</table>';
            container.innerHTML = html;
        }

        // Ajout de contr√¥les avanc√©s
        function addAdvancedControls() {
            const advancedDiv = document.createElement('div');
            advancedDiv.className = 'controls';
            advancedDiv.style.marginTop = '15px';
            advancedDiv.innerHTML = `
                <button onclick="runSensitivityAnalysis()" style="background: linear-gradient(45deg, #607D8B, #455A64);">
                    üìä Analyse Sensibilit√©
                </button>
                <button onclick="exportNetwork()" style="background: linear-gradient(45deg, #795548, #5D4037);">
                    üíæ Exporter R√©seau
                </button>
                <button onclick="compareModels()" style="background: linear-gradient(45deg, #00BCD4, #0097A7);">
                    ‚öñÔ∏è Comparer Mod√®les
                </button>
            `;
            document.querySelector('.container').appendChild(advancedDiv);
        }

        function exportNetwork() {
            const networkData = {
                structure: network,
                cpts: cpts,
                evidence: network.evidence,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(networkData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bayesian_network.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        async function compareModels() {
            if (isAnimating) return;
            isAnimating = true;
            
            // Simulation de comparaison entre mod√®les na√Øf et structur√©
            const container = document.querySelector('.scenario-info');
            
            const comparisons = [
                { model: 'Na√Øf Bayes', accuracy: 0.72, complexity: 'Faible' },
                { model: 'R√©seau Bay√©sien', accuracy: 0.89, complexity: 'Moyenne' },
                { model: 'R√©seau Bay√©sien Dynamique', accuracy: 0.94, complexity: '√âlev√©e' }
            ];
            
            let html = '<div class="scenario-title">‚öñÔ∏è Comparaison de Mod√®les</div>';
            html += '<table style="width: 100%; margin: 15px 0;"><tr><th>Mod√®le</th><th>Pr√©cision</th><th>Complexit√©</th></tr>';
            
            for (const comp of comparisons) {
                html += `<tr><td>${comp.model}</td><td>${(comp.accuracy * 100).toFixed(1)}%</td><td>${comp.complexity}</td></tr>`;
                container.innerHTML = html;
                await sleep(800);
            }
            
            html += '</table><p>Le r√©seau bay√©sien offre le meilleur compromis pr√©cision/complexit√©.</p>';
            container.innerHTML = html;
            
            isAnimating = false;
        }

        // Initialisation
        window.onload = function() {
            initializeNetwork();
            
            // Ajouter les contr√¥les avanc√©s apr√®s un d√©lai
            setTimeout(addAdvancedControls, 1000);
            
            // Message de bienvenue
            setTimeout(() => {
                const container = document.querySelector('.scenario-info');
                container.innerHTML += '<p><em>üí° Cliquez sur les n≈ìuds pour plus d\'informations, ajoutez des evidences et lancez l\'inf√©rence !</em></p>';
            }, 2000);
        };
    </script>
</body>
</html>