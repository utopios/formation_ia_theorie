<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Réseau Neuronal Bayésien</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1565C0 0%, #7B1FA2 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .forward-btn { background: linear-gradient(45deg, #4CAF50, #45a049); }
        .uncertainty-btn { background: linear-gradient(45deg, #FF9800, #F57C00); }
        .mcmc-btn { background: linear-gradient(45deg, #9C27B0, #7B1FA2); }
        .reset-btn { background: linear-gradient(45deg, #F44336, #D32F2F); }

        .bnn-container {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .concept-info {
            text-align: center;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .concept-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }

        .network-architecture {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .layer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .layer-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }

        .neuron {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.5s ease;
            border: 2px solid rgba(255, 255, 255, 0.5);
            position: relative;
        }

        .neuron:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .input-neuron { background: linear-gradient(135deg, #2196F3, #1976D2); }
        .hidden-neuron { background: linear-gradient(135deg, #4CAF50, #388E3C); }
        .output-neuron { background: linear-gradient(135deg, #FF5722, #D84315); }

        .neuron.active {
            animation: pulse-neuron 2s infinite;
            border-color: #FFD700;
            border-width: 3px;
        }

        @keyframes pulse-neuron {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
        }

        .weight-distribution {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gaussian-weight {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .connection {
            position: absolute;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            transform-origin: left center;
            transition: all 0.5s ease;
        }

        .connection.active {
            background: #FFD700;
            height: 4px;
            box-shadow: 0 0 10px #FFD700;
        }

        .uncertainty-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .uncertainty-box {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .uncertainty-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #FFD700;
            text-align: center;
        }

        .uncertainty-value {
            font-size: 2em;
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-family: monospace;
        }

        .distribution-viz {
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }

        .distribution-curve {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to top, rgba(76, 175, 80, 0.6), transparent);
        }

        .prediction-comparison {
            display: flex;
            justify-content: space-around;
            margin: 30px 0;
            flex-wrap: wrap;
            gap: 20px;
        }

        .prediction-box {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            flex: 1;
            min-width: 250px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .prediction-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #FFD700;
        }

        .prediction-value {
            font-size: 1.8em;
            margin: 10px 0;
            font-family: monospace;
        }

        .classical-nn { border-left: 4px solid #2196F3; }
        .bayesian-nn { border-left: 4px solid #9C27B0; }

        .confidence-interval {
            background: rgba(156, 39, 176, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .mcmc-visualization {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .mcmc-title {
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #9C27B0;
        }

        .chain-display {
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 15px 0;
        }

        .sample-point {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #9C27B0;
            transition: all 0.3s ease;
        }

        .sample-point.current {
            background: #FFD700;
            width: 10px;
            height: 10px;
            box-shadow: 0 0 10px #FFD700;
        }

        .parameter-table {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        th {
            background: rgba(255, 255, 255, 0.2);
            font-weight: bold;
        }

        .parameter-highlight {
            background: rgba(255, 215, 0, 0.3) !important;
            border: 2px solid #FFD700 !important;
        }

        .legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .formula-display {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: monospace;
            text-align: center;
        }

        .formula {
            font-size: 1.2em;
            margin: 10px 0;
            color: #FFD700;
        }

        @media (max-width: 768px) {
            .network-architecture {
                flex-direction: column;
            }
            
            .uncertainty-panel {
                grid-template-columns: 1fr;
            }
            
            .prediction-comparison {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧠 Animation Réseau Neuronal Bayésien</h1>
        
        <div class="controls">
            <button class="forward-btn" onclick="runForwardPass()">▶️ Forward Pass</button>
            <button class="uncertainty-btn" onclick="showUncertainty()">📊 Incertitude</button>
            <button class="mcmc-btn" onclick="runMCMC()">🔗 MCMC Sampling</button>
            <button onclick="comparePredictions()">⚖️ Comparer</button>
            <button class="reset-btn" onclick="resetBNN()">🔄 Reset</button>
        </div>

        <!-- Concept -->
        <div class="concept-info">
            <div class="concept-title">🎯 Réseaux de Neurones Bayésiens (BNN)</div>
            <p>Contrairement aux NN classiques avec des poids fixes, les BNN traitent les poids comme des distributions de probabilité, permettant de quantifier l'incertitude des prédictions.</p>
        </div>

        <div class="bnn-container">
            <!-- Architecture du réseau -->
            <div class="network-architecture" id="network-architecture">
                <div class="layer">
                    <div class="layer-title">📥 Entrée</div>
                    <div class="neuron input-neuron" onclick="selectNeuron('input', 0)">
                        x₁
                        <div class="weight-distribution gaussian-weight">N</div>
                    </div>
                    <div class="neuron input-neuron" onclick="selectNeuron('input', 1)">
                        x₂
                        <div class="weight-distribution gaussian-weight">N</div>
                    </div>
                </div>

                <div class="layer">
                    <div class="layer-title">🔗 Cachée</div>
                    <div class="neuron hidden-neuron" onclick="selectNeuron('hidden', 0)">
                        h₁
                        <div class="weight-distribution gaussian-weight">N</div>
                    </div>
                    <div class="neuron hidden-neuron" onclick="selectNeuron('hidden', 1)">
                        h₂
                        <div class="weight-distribution gaussian-weight">N</div>
                    </div>
                    <div class="neuron hidden-neuron" onclick="selectNeuron('hidden', 2)">
                        h₃
                        <div class="weight-distribution gaussian-weight">N</div>
                    </div>
                </div>

                <div class="layer">
                    <div class="layer-title">📤 Sortie</div>
                    <div class="neuron output-neuron" onclick="selectNeuron('output', 0)">
                        ŷ
                        <div class="weight-distribution gaussian-weight">N</div>
                    </div>
                </div>
            </div>

            <!-- Formules principales -->
            <div class="formula-display">
                <div class="formula">P(w | D) = P(D | w) × P(w) / P(D)</div>
                <div style="font-size: 0.9em; margin-top: 10px;">
                    Postérieur = Vraisemblance × Prior / Evidence
                </div>
            </div>

            <!-- Panneau d'incertitude -->
            <div class="uncertainty-panel">
                <div class="uncertainty-box">
                    <div class="uncertainty-title">📊 Incertitude Épistémique</div>
                    <div class="uncertainty-value" id="epistemic-uncertainty">±0.12</div>
                    <div class="distribution-viz">
                        <canvas id="epistemic-canvas" width="280" height="150"></canvas>
                    </div>
                    <div>Incertitude due au manque de données</div>
                </div>

                <div class="uncertainty-box">
                    <div class="uncertainty-title">🎲 Incertitude Aléatoire</div>
                    <div class="uncertainty-value" id="aleatoric-uncertainty">±0.08</div>
                    <div class="distribution-viz">
                        <canvas id="aleatoric-canvas" width="280" height="150"></canvas>
                    </div>
                    <div>Incertitude intrinsèque aux données</div>
                </div>

                <div class="uncertainty-box">
                    <div class="uncertainty-title">🔄 Incertitude Totale</div>
                    <div class="uncertainty-value" id="total-uncertainty">±0.15</div>
                    <div class="distribution-viz">
                        <canvas id="total-canvas" width="280" height="150"></canvas>
                    </div>
                    <div>√(Épistémique² + Aléatoire²)</div>
                </div>
            </div>

            <!-- Comparaison des prédictions -->
            <div class="prediction-comparison">
                <div class="prediction-box classical-nn">
                    <div class="prediction-title">🤖 Réseau Neuronal Classique</div>
                    <div class="prediction-value" id="classical-prediction">0.73</div>
                    <div style="color: #FF5722;">❌ Pas d'information sur l'incertitude</div>
                    <div style="font-size: 0.9em; margin-top: 10px;">
                        Poids fixes après entraînement
                    </div>
                </div>

                <div class="prediction-box bayesian-nn">
                    <div class="prediction-title">🎯 Réseau Neuronal Bayésien</div>
                    <div class="prediction-value" id="bayesian-prediction">0.71</div>
                    <div class="confidence-interval" id="confidence-interval">
                        IC 95%: [0.56, 0.86]
                    </div>
                    <div style="color: #4CAF50;">✅ Quantification de l'incertitude</div>
                    <div style="font-size: 0.9em; margin-top: 10px;">
                        Distributions sur les poids
                    </div>
                </div>
            </div>

            <!-- Visualisation MCMC -->
            <div class="mcmc-visualization" id="mcmc-viz">
                <div class="mcmc-title">🔗 Échantillonnage MCMC des Poids</div>
                <div class="chain-display" id="chain-display"></div>
                <div class="parameter-table">
                    <table>
                        <tr>
                            <th>Paramètre</th>
                            <th>Moyenne</th>
                            <th>Écart-type</th>
                            <th>ESS</th>
                        </tr>
                        <tr id="w1-row">
                            <td>w₁</td>
                            <td id="w1-mean">0.42</td>
                            <td id="w1-std">0.15</td>
                            <td id="w1-ess">850</td>
                        </tr>
                        <tr id="w2-row">
                            <td>w₂</td>
                            <td id="w2-mean">-0.28</td>
                            <td id="w2-std">0.18</td>
                            <td id="w2-ess">920</td>
                        </tr>
                        <tr id="w3-row">
                            <td>w₃</td>
                            <td id="w3-mean">0.65</td>
                            <td id="w3-std">0.12</td>
                            <td id="w3-ess">780</td>
                        </tr>
                    </table>
                </div>
            </div>

            <!-- Légende -->
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>Neurone d'entrée</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>Neurone caché</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF5722;"></div>
                    <span>Neurone de sortie</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50; border-radius: 50%;"></div>
                    <span>Distribution Gaussienne</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFD700;"></div>
                    <span>Connexion Active</span>
                </div>
            </div>
        </div>

        <!-- Explication détaillée -->
        <div class="bnn-container">
            <div class="concept-title">🎓 Avantages des Réseaux Neuronaux Bayésiens</div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0;">
                <div style="background: rgba(76, 175, 80, 0.2); padding: 15px; border-radius: 10px;">
                    <strong>✅ Quantification d'Incertitude</strong><br>
                    Fournit des intervalles de confiance pour chaque prédiction
                </div>
                <div style="background: rgba(33, 150, 243, 0.2); padding: 15px; border-radius: 10px;">
                    <strong>🛡️ Robustesse</strong><br>
                    Moins susceptible au sur-apprentissage grâce aux priors
                </div>
                <div style="background: rgba(255, 152, 0, 0.2); padding: 15px; border-radius: 10px;">
                    <strong>🎯 Prise de Décision</strong><br>
                    Permet de prendre des décisions informées basées sur l'incertitude
                </div>
                <div style="background: rgba(156, 39, 176, 0.2); padding: 15px; border-radius: 10px;">
                    <strong>🔍 Détection d'Anomalies</strong><br>
                    Identifie les données hors distribution par l'incertitude élevée
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration du BNN
        const bnnConfig = {
            inputSize: 2,
            hiddenSize: 3,
            outputSize: 1,
            samples: 1000,
            burnIn: 200
        };

        // Variables globales
        let isAnimating = false;
        let mcmcSamples = [];
        let currentSample = 0;
        let weights = {
            input_to_hidden: generateWeightDistributions(bnnConfig.inputSize, bnnConfig.hiddenSize),
            hidden_to_output: generateWeightDistributions(bnnConfig.hiddenSize, bnnConfig.outputSize)
        };

        // Génération des distributions de poids
        function generateWeightDistributions(input, output) {
            const distributions = [];
            for (let i = 0; i < input; i++) {
                distributions[i] = [];
                for (let j = 0; j < output; j++) {
                    distributions[i][j] = {
                        mean: (Math.random() - 0.5) * 2,
                        std: Math.random() * 0.5 + 0.1
                    };
                }
            }
            return distributions;
        }

        // Échantillonnage gaussien
        function sampleGaussian(mean, std) {
            const u1 = Math.random();
            const u2 = Math.random();
            const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mean + std * z0;
        }

        // Forward pass avec échantillonnage
        async function runForwardPass() {
            if (isAnimating) return;
            isAnimating = true;

            // Réinitialiser les animations
            document.querySelectorAll('.neuron').forEach(n => n.classList.remove('active'));
            
            // Animer les neurones d'entrée
            await animateLayer('input');
            
            // Échantillonner les poids input->hidden et calculer
            const inputValues = [0.5, 0.3]; // Valeurs d'exemple
            const hiddenValues = [];
            
            for (let h = 0; h < bnnConfig.hiddenSize; h++) {
                let sum = 0;
                for (let i = 0; i < bnnConfig.inputSize; i++) {
                    const weight = sampleGaussian(
                        weights.input_to_hidden[i][h].mean,
                        weights.input_to_hidden[i][h].std
                    );
                    sum += inputValues[i] * weight;
                }
                hiddenValues[h] = Math.tanh(sum); // Activation
            }
            
            // Animer les neurones cachés
            await animateLayer('hidden');
            
            // Calculer la sortie
            let outputSum = 0;
            for (let h = 0; h < bnnConfig.hiddenSize; h++) {
                const weight = sampleGaussian(
                    weights.hidden_to_output[h][0].mean,
                    weights.hidden_to_output[h][0].std
                );
                outputSum += hiddenValues[h] * weight;
            }
            
            const output = 1 / (1 + Math.exp(-outputSum)); // Sigmoid
            
            // Animer le neurone de sortie
            await animateLayer('output');
            
            // Mettre à jour l'affichage
            updatePredictions(output);
            
            isAnimating = false;
        }

        async function animateLayer(layerType) {
            const neurons = document.querySelectorAll(`.${layerType}-neuron`);
            
            for (let neuron of neurons) {
                neuron.classList.add('active');
                await sleep(300);
            }
            
            await sleep(500);
            
            neurons.forEach(neuron => neuron.classList.remove('active'));
        }

        function updatePredictions(bayesianOutput) {
            // Prédiction classique (simulée)
            const classicalOutput = 0.73 + (Math.random() - 0.5) * 0.1;
            document.getElementById('classical-prediction').textContent = classicalOutput.toFixed(2);
            
            // Prédiction bayésienne
            document.getElementById('bayesian-prediction').textContent = bayesianOutput.toFixed(2);
            
            // Intervalle de confiance (simulé)
            const uncertainty = 0.15;
            const lowerBound = Math.max(0, bayesianOutput - uncertainty);
            const upperBound = Math.min(1, bayesianOutput + uncertainty);
            document.getElementById('confidence-interval').innerHTML = 
                `IC 95%: [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]`;
        }

        async function showUncertainty() {
            if (isAnimating) return;
            isAnimating = true;

            // Simuler plusieurs forward passes pour estimer l'incertitude
            const predictions = [];
            const numSamples = 100;
            
            for (let i = 0; i < numSamples; i++) {
                // Forward pass simplifié
                const inputValues = [0.5, 0.3];
                const hiddenValues = [];
                
                for (let h = 0; h < bnnConfig.hiddenSize; h++) {
                    let sum = 0;
                    for (let inp = 0; inp < bnnConfig.inputSize; inp++) {
                        const weight = sampleGaussian(
                            weights.input_to_hidden[inp][h].mean,
                            weights.input_to_hidden[inp][h].std
                        );
                        sum += inputValues[inp] * weight;
                    }
                    hiddenValues[h] = Math.tanh(sum);
                }
                
                let outputSum = 0;
                for (let h = 0; h < bnnConfig.hiddenSize; h++) {
                    const weight = sampleGaussian(
                        weights.hidden_to_output[h][0].mean,
                        weights.hidden_to_output[h][0].std
                    );
                    outputSum += hiddenValues[h] * weight;
                }
                
                predictions.push(1 / (1 + Math.exp(-outputSum)));
                
                // Animation progressive
                if (i % 20 === 0) {
                    updateUncertaintyDisplay(predictions);
                    await sleep(200);
                }
            }
            
            // Calcul final des incertitudes
            updateUncertaintyDisplay(predictions);
            drawUncertaintyDistributions(predictions);
            
            isAnimating = false;
        }

        function updateUncertaintyDisplay(predictions) {
            const mean = predictions.reduce((a, b) => a + b, 0) / predictions.length;
            const variance = predictions.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / predictions.length;
            const std = Math.sqrt(variance);
            
            // Simulation des différents types d'incertitude
            const epistemicUncertainty = std * 0.8; // Due au modèle
            const aleatoricUncertainty = std * 0.6; // Due aux données
            const totalUncertainty = Math.sqrt(epistemicUncertainty**2 + aleatoricUncertainty**2);
            
            document.getElementById('epistemic-uncertainty').textContent = `±${epistemicUncertainty.toFixed(3)}`;
            document.getElementById('aleatoric-uncertainty').textContent = `±${aleatoricUncertainty.toFixed(3)}`;
            document.getElementById('total-uncertainty').textContent = `±${totalUncertainty.toFixed(3)}`;
        }

        function drawUncertaintyDistributions(predictions) {
            // Dessiner les distributions sur les canvas
            const canvases = ['epistemic-canvas', 'aleatoric-canvas', 'total-canvas'];
            
            canvases.forEach(canvasId => {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Dessiner une courbe gaussienne simulée
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < canvas.width; x++) {
                    const normalizedX = (x / canvas.width - 0.5) * 4; // Range [-2, 2]
                    const y = Math.exp(-0.5 * normalizedX * normalizedX);
                    const canvasY = canvas.height - (y * canvas.height);
                    
                    if (x === 0) {
                        ctx.moveTo(x, canvasY);
                    } else {
                        ctx.lineTo(x, canvasY);
                    }
                }
                
                ctx.stroke();
                
                // Remplir sous la courbe
                ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                ctx.fill();
            });
        }

        async function runMCMC() {
            if (isAnimating) return;
            isAnimating = true;

            document.getElementById('mcmc-viz').style.display = 'block';
            
            const chainDisplay = document.getElementById('chain-display');
            chainDisplay.innerHTML = '';
            
            mcmcSamples = [];
            currentSample = 0;
            
            // Simuler l'échantillonnage MCMC
            let currentWeight = 0.5;
            
            for (let i = 0; i < 200; i++) {
                // Proposition Metropolis-Hastings
                const proposal = currentWeight + (Math.random() - 0.5) * 0.2;
                
                // Accepter/rejeter (simplifié)
                const acceptanceProb = Math.exp(-0.5 * proposal * proposal); // Prior gaussien
                
                if (Math.random() < acceptanceProb) {
                    currentWeight = proposal;
                }
                
                mcmcSamples.push(currentWeight);
                
                // Visualisation
                if (i % 10 === 0) {
                    await animateMCMCSample(currentWeight, i);
                    updateMCMCStats();
                }
            }
            
            isAnimating = false;
        }

        async function animateMCMCSample(weight, iteration) {
            const chainDisplay = document.getElementById('chain-display');
            
            // Créer un point d'échantillon
            const point = document.createElement('div');
            point.className = 'sample-point current';
            
            const x = (iteration / 200) * chainDisplay.offsetWidth;
            const y = chainDisplay.offsetHeight - ((weight + 2) / 4) * chainDisplay.offsetHeight;
            
            point.style.left = x + 'px';
            point.style.top = y + 'px';
            
            chainDisplay.appendChild(point);
            
            // Enlever la classe 'current' du point précédent
            setTimeout(() => {
                const previousPoints = chainDisplay.querySelectorAll('.sample-point.current');
                previousPoints.forEach((p, i) => {
                    if (i < previousPoints.length - 1) {
                        p.classList.remove('current');
                    }
                });
            }, 300);
            
            await sleep(100);
        }

        function updateMCMCStats() {
            if (mcmcSamples.length === 0) return;
            
            const mean = mcmcSamples.reduce((a, b) => a + b, 0) / mcmcSamples.length;
            const variance = mcmcSamples.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / mcmcSamples.length;
            const std = Math.sqrt(variance);
            
            // Mise à jour des statistiques
            document.getElementById('w1-mean').textContent = mean.toFixed(3);
            document.getElementById('w1-std').textContent = std.toFixed(3);
            document.getElementById('w1-ess').textContent = Math.floor(mcmcSamples.length * 0.8);
            
            // Mise à jour des autres poids (simulé)
            document.getElementById('w2-mean').textContent = (mean * 0.8 + 0.1).toFixed(3);
            document.getElementById('w2-std').textContent = (std * 1.2).toFixed(3);
            
            document.getElementById('w3-mean').textContent = (mean * 1.3 - 0.2).toFixed(3);
            document.getElementById('w3-std').textContent = (std * 0.9).toFixed(3);
        }

        async function comparePredictions() {
            if (isAnimating) return;
            isAnimating = true;
            
            // Animation de comparaison
            const classicalBox = document.querySelector('.classical-nn');
            const bayesianBox = document.querySelector('.bayesian-nn');
            
            // Mettre en évidence les différences
            for (let i = 0; i < 3; i++) {
                classicalBox.style.borderColor = '#FF5722';
                bayesianBox.style.borderColor = '#9C27B0';
                await sleep(500);
                
                classicalBox.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                bayesianBox.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                await sleep(500);
            }
            
            // Afficher un résumé de comparaison
            showComparisonSummary();
            
            isAnimating = false;
        }

        function showComparisonSummary() {
            const summary = `
                📊 Comparaison NN Classique vs BNN:
                
                🤖 NN Classique:
                • Prédiction: Point unique
                • Incertitude: Non quantifiée
                • Confiance: Toujours élevée
                • Robustesse: Limitée
                
                🎯 BNN:
                • Prédiction: Distribution
                • Incertitude: Quantifiée
                • Confiance: Adaptive
                • Robustesse: Élevée
                
                ✅ Le BNN est plus adapté pour les applications critiques !
            `;
            
            alert(summary);
        }

        function selectNeuron(layer, index) {
            if (isAnimating) return;
            
            const neuronInfo = {
                input: `Neurone d'entrée ${index + 1}\nReçoit les données d'entrée\nPoids distribués selon N(μ, σ²)`,
                hidden: `Neurone caché ${index + 1}\nApplique une activation non-linaire\nPoids bayésiens avec priors`,
                output: `Neurone de sortie\nProduit la prédiction finale\nIncertitude propagée depuis les couches précédentes`
            };
            
            alert(neuronInfo[layer]);
        }

        function resetBNN() {
            isAnimating = false;
            mcmcSamples = [];
            currentSample = 0;
            
            // Reset de l'interface
            document.querySelectorAll('.neuron').forEach(n => n.classList.remove('active'));
            document.getElementById('mcmc-viz').style.display = 'none';
            
            // Reset des valeurs
            document.getElementById('classical-prediction').textContent = '0.73';
            document.getElementById('bayesian-prediction').textContent = '0.71';
            document.getElementById('confidence-interval').innerHTML = 'IC 95%: [0.56, 0.86]';
            
            document.getElementById('epistemic-uncertainty').textContent = '±0.12';
            document.getElementById('aleatoric-uncertainty').textContent = '±0.08';
            document.getElementById('total-uncertainty').textContent = '±0.15';
            
            // Régénérer les poids
            weights = {
                input_to_hidden: generateWeightDistributions(bnnConfig.inputSize, bnnConfig.hiddenSize),
                hidden_to_output: generateWeightDistributions(bnnConfig.hiddenSize, bnnConfig.outputSize)
            };
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Fonctions avancées
        async function runVariationalInference() {
            if (isAnimating) return;
            isAnimating = true;
            
            alert('Inférence Variationnelle:\n\n' +
                  '• Approxime la postérieur P(w|D) par une distribution plus simple q(w)\n' +
                  '• Minimise la divergence KL entre q(w) et P(w|D)\n' +
                  '• Plus rapide que MCMC mais moins précise\n' +
                  '• Utilisée dans les BNN pour l\'efficacité computationnelle');
            
            isAnimating = false;
        }

        // Initialisation
        window.onload = function() {
            // Dessiner les distributions initiales
            drawUncertaintyDistributions([0.7, 0.65, 0.8, 0.72, 0.69]);
            
            // Ajouter des contrôles avancés
            setTimeout(() => {
                const advancedDiv = document.createElement('div');
                advancedDiv.className = 'controls';
                advancedDiv.style.marginTop = '15px';
                advancedDiv.innerHTML = `
                    <button onclick="runVariationalInference()" style="background: linear-gradient(45deg, #607D8B, #455A64);">
                        📐 Inférence Variationnelle
                    </button>
                    <button onclick="showPriors()" style="background: linear-gradient(45deg, #795548, #5D4037);">
                        📋 Visualiser Priors
                    </button>
                    <button onclick="showApplications()" style="background: linear-gradient(45deg, #009688, #00695C);">
                        🚀 Applications
                    </button>
                `;
                document.querySelector('.container').appendChild(advancedDiv);
            }, 1000);
        };

        function showPriors() {
            alert('Priors Bayésiens:\n\n' +
                  '• Poids W ~ N(0, 1) : Prior gaussien centré\n' +
                  '• Biais b ~ N(0, 0.1) : Prior avec faible variance\n' +
                  '• Précision τ ~ Gamma(1, 1) : Prior sur l\'incertitude\n\n' +
                  'Les priors régularisent le modèle et encodent nos croyances a priori.');
        }

        function showApplications() {
            alert('Applications des BNN:\n\n' +
                  '🏥 Médical: Diagnostic avec quantification d\'incertitude\n' +
                  '🚗 Autonome: Conduite avec conscience de l\'incertitude\n' +
                  '💰 Finance: Prédictions avec estimation du risque\n' +
                  '🌤️ Météo: Prévisions probabilistes\n' +
                  '🔬 Sciences: Modélisation avec incertitude\n' +
                  '🛡️ Sécurité: Détection d\'anomalies\n\n' +
                  'Partout où l\'incertitude est critique !');
        }
    </script>
</body>
</html>